---
title: Session State
sidebarTitle: Session State
description: Share data between workflow steps and across runs
---

## What is Session State?

Session state is a shared dictionary that lets your workflow steps pass data to each other and persist information across multiple workflow runs. Think of it as a scratchpad that all your steps can read from and write to, and that survives between executions.

Unlike workflow history (which stores complete run results), session state is for real-time data sharing within and across runs.

## Why Use Session State?

Session state is useful when you need to:

- **Share data between steps** without passing it through step outputs
- **Maintain counters or accumulators** across workflow executions
- **Track workflow progress** or state across multiple runs  
- **Store user preferences** that affect subsequent runs
- **Coordinate between steps** with shared flags or status information
- **Build up collections** of data over multiple runs

## How Session State Works

When you initialize session state on a workflow:

1. The workflow stores it in the database with the session
2. Each step gets a **copy** of the current state
3. Steps can read from and modify their copy
4. After the step completes, changes are **merged back** into the main state
5. The updated state is saved to the database
6. The next run loads the persisted state from the database

```python
from agno.workflow import Workflow

workflow = Workflow(
    name="Task Manager",
    db=SqliteDb(db_file="tasks.db"),
    steps=[...],
    session_state={"tasks": [], "counter": 0},  # Initial state
)

# First run - state starts with initial values
workflow.run(input="Add task 1")  # counter becomes 1

# Second run - state persists from first run
workflow.run(input="Add task 2")  # counter becomes 2
```

## Initializing Session State

Set the initial state when creating your workflow:

```python
workflow = Workflow(
    name="Shopping List Manager",
    db=SqliteDb(db_file="shopping.db"),
    steps=[...],
    session_state={
        "shopping_list": [],
        "budget": 100.0,
        "user_preferences": {
            "organic_only": False,
            "max_items": 20,
        },
    },
)
```

<Note>
Session state must be a dictionary. You can nest dictionaries, use lists, numbers, strings, or any JSON-serializable data.
</Note>

## Accessing Session State in Steps

### In Custom Functions

Custom function steps can accept a `session_state` parameter:

```python
from agno.workflow.step import Step, StepInput, StepOutput

def add_item_to_list(step_input: StepInput, session_state: dict) -> StepOutput:
    """Custom function that uses session state"""
    item = step_input.input
    
    # Read from session state
    items = session_state.get("items", [])
    
    # Modify session state
    items.append(item)
    session_state["items"] = items
    session_state["item_count"] = len(items)
    
    return StepOutput(content=f"Added {item}. Total items: {len(items)}")

workflow = Workflow(
    name="List Manager",
    db=SqliteDb(db_file="lists.db"),
    steps=[
        Step(name="Add Item", executor=add_item_to_list),
    ],
    session_state={"items": [], "item_count": 0},
)
```

<Check>
When your custom function has a `session_state` parameter, Agno automatically passes the state dict to it. Changes you make are automatically merged back.
</Check>

### In Agent and Team Tools

Agents and teams inside workflow steps can access session state through tools:

```python
from agno.agent import Agent

def add_to_cart(session_state: dict, item: str, price: float) -> str:
    """Tool that accesses session state"""
    cart = session_state.get("cart", [])
    cart.append({"item": item, "price": price})
    session_state["cart"] = cart
    
    total = sum(item["price"] for item in cart)
    return f"Added {item} (${price}). Cart total: ${total}"

shopping_agent = Agent(
    name="Shopping Assistant",
    tools=[add_to_cart],
    instructions="Help users add items to their cart",
)

workflow = Workflow(
    name="Shopping Workflow",
    db=SqliteDb(db_file="shop.db"),
    steps=[
        Step(name="Shop", agent=shopping_agent),
    ],
    session_state={"cart": []},
)
```

### In Condition Evaluators

Condition evaluators can use session state to make decisions:

```python
from agno.workflow.condition import Condition

def check_budget_exceeded(step_input: StepInput, session_state: dict) -> bool:
    """Condition that checks session state"""
    total_spent = session_state.get("total_spent", 0)
    budget = session_state.get("budget", 100)
    
    # Update counter
    session_state["budget_checks"] = session_state.get("budget_checks", 0) + 1
    
    return total_spent > budget

workflow = Workflow(
    name="Budget Tracker",
    db=SqliteDb(db_file="budget.db"),
    steps=[
        Step(name="Process Purchase", agent=purchaser),
        Condition(
            name="Budget Check",
            evaluator=check_budget_exceeded,
            steps=[
                Step(name="Send Alert", agent=alerter),
            ],
        ),
    ],
    session_state={"total_spent": 0, "budget": 100},
)
```

### In Router Selectors

Router selectors can use session state to choose routes:

```python
from agno.workflow.router import Router

def route_by_history(step_input: StepInput, session_state: dict) -> Step:
    """Router that uses session state"""
    interaction_count = session_state.get("interaction_count", 0)
    session_state["interaction_count"] = interaction_count + 1
    
    if interaction_count == 0:
        return welcome_step
    else:
        return continuing_step

workflow = Workflow(
    name="Adaptive Workflow",
    db=SqliteDb(db_file="adaptive.db"),
    steps=[
        Router(
            name="Route by Experience",
            selector=route_by_history,
            choices=[welcome_step, continuing_step],
        ),
    ],
    session_state={"interaction_count": 0},
)
```

## Reading and Updating State Programmatically

### Get Current State

```python
# Get the current session state
state = workflow.get_session_state(session_id="user-123")

print(f"Items: {state['items']}")
print(f"Counter: {state['counter']}")
```

### Update State Directly

```python
# Update specific keys in session state
workflow.update_session_state(
    session_state_updates={
        "user_preference": "dark_mode",
        "notification_enabled": True,
    },
    session_id="user-123",
)
```

### Async Methods

```python
# Async versions
state = await workflow.aget_session_state(session_id="user-123")
await workflow.aupdate_session_state(
    session_state_updates={"key": "value"},
    session_id="user-123",
)
```

## Automatic State Enrichment

When a workflow step executes, Agno automatically adds these fields to session state:

```python
{
    "current_user_id": "user-123",      # From workflow.user_id or run parameter
    "current_session_id": "session-abc", # Current session ID
    "current_run_id": "run-xyz",        # Current run ID
    "workflow_id": "workflow-123",      # Workflow ID
    "workflow_name": "My Workflow",     # Workflow name (if set)
    "session_id": "session-abc",        # Session ID (duplicate of current_session_id)
    "run_id": "run-xyz",                # Run ID (duplicate of current_run_id)
}
```

These fields are automatically removed before saving to the database, so they don't clutter your persistent state.

## Common Patterns

### Counter Pattern

Track how many times something has happened:

```python
def process_request(step_input: StepInput, session_state: dict) -> StepOutput:
    # Increment counter
    count = session_state.get("request_count", 0) + 1
    session_state["request_count"] = count
    
    return StepOutput(content=f"Request #{count} processed")

workflow = Workflow(
    name="Request Processor",
    db=SqliteDb(db_file="requests.db"),
    steps=[Step(name="Process", executor=process_request)],
    session_state={"request_count": 0},
)
```

### List Accumulator Pattern

Build up a collection over multiple runs:

```python
def collect_feedback(step_input: StepInput, session_state: dict) -> StepOutput:
    feedback = step_input.input
    
    # Add to collection
    all_feedback = session_state.get("feedback_list", [])
    all_feedback.append({
        "feedback": feedback,
        "timestamp": time.time(),
    })
    session_state["feedback_list"] = all_feedback
    
    return StepOutput(content=f"Collected {len(all_feedback)} feedback items")

workflow = Workflow(
    name="Feedback Collector",
    db=SqliteDb(db_file="feedback.db"),
    steps=[Step(name="Collect", executor=collect_feedback)],
    session_state={"feedback_list": []},
)
```

### State Machine Pattern

Track which stage the workflow is in:

```python
def advance_stage(step_input: StepInput, session_state: dict) -> StepOutput:
    stages = ["init", "processing", "review", "complete"]
    current = session_state.get("stage", "init")
    
    # Find next stage
    current_index = stages.index(current)
    next_stage = stages[min(current_index + 1, len(stages) - 1)]
    session_state["stage"] = next_stage
    
    return StepOutput(content=f"Advanced to stage: {next_stage}")

workflow = Workflow(
    name="Multi-Stage Process",
    db=SqliteDb(db_file="process.db"),
    steps=[Step(name="Advance", executor=advance_stage)],
    session_state={"stage": "init"},
)
```

### Conditional Execution Pattern

Use state to control workflow behavior:

```python
def should_run_cleanup(step_input: StepInput, session_state: dict) -> bool:
    # Run cleanup every 10 runs
    run_count = session_state.get("run_count", 0)
    session_state["run_count"] = run_count + 1
    return run_count % 10 == 0

workflow = Workflow(
    name="Periodic Cleanup",
    db=SqliteDb(db_file="cleanup.db"),
    steps=[
        Step(name="Main Task", agent=worker),
        Condition(
            name="Cleanup Check",
            evaluator=should_run_cleanup,
            steps=[Step(name="Cleanup", agent=cleaner)],
        ),
    ],
    session_state={"run_count": 0},
)
```

## Session State vs Workflow History

Understanding when to use each:

| Feature | Session State | Workflow History |
|---------|--------------|------------------|
| **Purpose** | Share data between steps | Access previous run results |
| **Scope** | Single run + persisted | Previous completed runs only |
| **Mutability** | Read and write | Read only |
| **Size** | Keep small (frequently updated) | Can be large (historical data) |
| **Use for** | Counters, flags, progress tracking | Learning from past executions |
| **Access** | `session_state` parameter | `add_workflow_history_to_steps=True` |

### Using Both Together

You can use session state and workflow history in the same workflow:

```python
def smart_writer(step_input: StepInput, session_state: dict) -> StepOutput:
    # Use session state for tracking
    articles_written = session_state.get("article_count", 0)
    session_state["article_count"] = articles_written + 1
    
    # Workflow history is automatically prepended to input
    # (if add_workflow_history=True)
    # So the agent can see previous articles
    
    return StepOutput(content=f"Article #{articles_written + 1} completed")

workflow = Workflow(
    name="Article Generator",
    db=SqliteDb(db_file="articles.db"),
    steps=[
        Step(
            name="Write",
            agent=writer,
            add_workflow_history=True,  # See previous articles
        ),
    ],
    session_state={"article_count": 0},  # Track total count
    add_workflow_history_to_steps=True,
)
```

## Overwriting Database State

By default, session state from the database is merged with new state. You can override this:

```python
workflow = Workflow(
    name="Reset State Workflow",
    db=SqliteDb(db_file="workflow.db"),
    steps=[...],
    session_state={"counter": 0},
    overwrite_db_session_state=True,  # Always use provided state, ignore DB
)

# This resets the counter to 0 each time, ignoring saved state
workflow.run(input="Process")
```

<Warning>
Setting `overwrite_db_session_state=True` means the provided `session_state` always overwrites what's in the database. Use this carefully as it prevents state persistence.
</Warning>

## Best Practices

### Keep State Small and Focused

```python
# Good: Focused state
session_state = {
    "task_count": 0,
    "last_task_type": None,
}

# Avoid: Storing large data
session_state = {
    "all_historical_data": [...],  # Don't store large collections
    "full_documents": [...],        # Use workflow history instead
}
```

### Initialize All Keys

```python
# Good: All keys initialized
session_state = {
    "counter": 0,
    "enabled": False,
    "items": [],
    "metadata": {},
}

# Avoid: Relying on .get() everywhere
# Better to set defaults upfront
```

### Use Descriptive Names

```python
# Good: Clear purpose
session_state = {
    "budget_check_count": 0,
    "user_verified": False,
    "pending_approvals": [],
}

# Avoid: Ambiguous names
session_state = {
    "count": 0,
    "flag": False,
    "list": [],
}
```

### Document State Structure

```python
workflow = Workflow(
    name="Complex Workflow",
    db=SqliteDb(db_file="workflow.db"),
    steps=[...],
    session_state={
        # Counter for tracking workflow executions
        "execution_count": 0,
        
        # List of processed item IDs to avoid duplicates
        "processed_items": [],
        
        # User preference flags
        "preferences": {
            "notifications": True,
            "detailed_logs": False,
        },
    },
)
```

## Troubleshooting

### State Changes Not Persisting

If your state modifications aren't being saved:

1. **Check you have a database:** Session state requires `db` parameter
2. **Verify parameter name:** Must be exactly `session_state` (not `state` or `session`)
3. **Check function signature:** Function must accept `session_state` parameter

```python
# Correct
def my_function(step_input: StepInput, session_state: dict) -> StepOutput:
    session_state["counter"] = 1  # âœ… Will persist
    
# Incorrect
def my_function(step_input: StepInput) -> StepOutput:
    # No session_state parameter - can't access state
```

### State Resets on Each Run

If state keeps resetting:

1. **Check `overwrite_db_session_state`:** Should be `False` (default)
2. **Verify session ID:** Different session IDs have separate states
3. **Check database setup:** Ensure database is properly configured

### State Not Shared Between Steps

If steps aren't seeing each other's changes:

- **This is expected behavior:** Each step gets a copy
- **Changes merge after step completes:** Not visible during the same run
- **Use step outputs for within-run data passing:** Session state is for cross-run persistence

## Next Steps

- **[Workflow Naming](/basics/sessions/workflow-sessions/workflow-naming)** - Organize and identify your workflow sessions
- **[Workflow Agents](/basics/sessions/workflow-sessions/workflow-agents)** - Use agents that decide when to run workflows
- **[Metrics](/basics/sessions/workflow-sessions/metrics)** - Track workflow performance

## Developer Resources

- View [session state examples](https://github.com/agno-agi/agno/tree/main/cookbook/workflows/_06_advanced_concepts/_04_shared_session_state)
- See the [Workflow API](/reference/workflows/workflow)

