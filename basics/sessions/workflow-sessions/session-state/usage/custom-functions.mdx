---
title: Session State in Custom Functions
sidebarTitle: Custom Functions
description: Access and modify session state from custom function steps
---

## Basic Usage

Custom function steps can accept a `session_state` parameter to access and modify the shared state:

```python
from agno.workflow.step import Step, StepInput, StepOutput
from agno.workflow import Workflow
from agno.db.sqlite import SqliteDb

def process_item(step_input: StepInput, session_state: dict) -> StepOutput:
    """Custom function that uses session state"""
    item = step_input.input
    
    # Read from session state
    items = session_state.get("items", [])
    count = session_state.get("count", 0)
    
    # Modify session state
    items.append(item)
    session_state["items"] = items
    session_state["count"] = count + 1
    
    return StepOutput(content=f"Processed {item}. Total: {count + 1}")

workflow = Workflow(
    name="Item Processor",
    db=SqliteDb(db_file="processor.db"),
    steps=[
        Step(name="Process", executor=process_item),
    ],
    session_state={"items": [], "count": 0},
)

# Run multiple times
workflow.run(input="item1")
workflow.run(input="item2")
workflow.run(input="item3")
```

<Check>
When your custom function has a `session_state` parameter, Agno automatically passes the state dict to it. Changes you make are automatically merged back.
</Check>

## Counter Example

Track how many times a function has been called:

```python
def increment_counter(step_input: StepInput, session_state: dict) -> StepOutput:
    # Get current count
    count = session_state.get("execution_count", 0)
    
    # Increment
    count += 1
    session_state["execution_count"] = count
    
    # Optional: track execution history
    history = session_state.get("execution_history", [])
    history.append({
        "run": count,
        "input": step_input.input,
    })
    session_state["execution_history"] = history
    
    return StepOutput(content=f"Execution #{count}")

workflow = Workflow(
    name="Counter Workflow",
    db=SqliteDb(db_file="counter.db"),
    steps=[Step(name="Count", executor=increment_counter)],
    session_state={"execution_count": 0, "execution_history": []},
)
```

## Accumulator Example

Build up collections over multiple runs:

```python
def collect_feedback(step_input: StepInput, session_state: dict) -> StepOutput:
    feedback = step_input.input
    
    # Get existing feedback
    all_feedback = session_state.get("feedback_list", [])
    
    # Add new feedback with metadata
    all_feedback.append({
        "feedback": feedback,
        "run_number": len(all_feedback) + 1,
    })
    session_state["feedback_list"] = all_feedback
    
    # Update summary stats
    session_state["total_feedback"] = len(all_feedback)
    
    return StepOutput(
        content=f"Collected feedback #{len(all_feedback)}: {feedback}"
    )

workflow = Workflow(
    name="Feedback Collector",
    db=SqliteDb(db_file="feedback.db"),
    steps=[Step(name="Collect", executor=collect_feedback)],
    session_state={"feedback_list": [], "total_feedback": 0},
)
```

## State Machine Example

Implement a state machine with custom functions:

```python
def process_stage(step_input: StepInput, session_state: dict) -> StepOutput:
    stages = ["init", "processing", "review", "complete"]
    
    # Get current stage
    current_stage = session_state.get("stage", "init")
    current_index = stages.index(current_stage)
    
    # Advance to next stage
    if current_index < len(stages) - 1:
        next_stage = stages[current_index + 1]
        session_state["stage"] = next_stage
        session_state["stage_history"] = session_state.get("stage_history", []) + [next_stage]
        
        return StepOutput(content=f"Advanced to stage: {next_stage}")
    else:
        return StepOutput(content="Already at final stage")

workflow = Workflow(
    name="Stage Processor",
    db=SqliteDb(db_file="stages.db"),
    steps=[Step(name="Process", executor=process_stage)],
    session_state={"stage": "init", "stage_history": ["init"]},
)
```

## Complex Data Structures

Work with nested dictionaries and lists:

```python
def update_user_profile(step_input: StepInput, session_state: dict) -> StepOutput:
    # Initialize nested structure if needed
    if "user_profile" not in session_state:
        session_state["user_profile"] = {
            "preferences": {},
            "activity": [],
            "stats": {"total_actions": 0},
        }
    
    profile = session_state["user_profile"]
    
    # Update preferences
    profile["preferences"]["last_action"] = step_input.input
    
    # Track activity
    profile["activity"].append({
        "action": step_input.input,
        "count": len(profile["activity"]) + 1,
    })
    
    # Update stats
    profile["stats"]["total_actions"] += 1
    
    return StepOutput(
        content=f"Profile updated. Total actions: {profile['stats']['total_actions']}"
    )

workflow = Workflow(
    name="Profile Manager",
    db=SqliteDb(db_file="profiles.db"),
    steps=[Step(name="Update", executor=update_user_profile)],
    session_state={},
)
```

## Conditional Logic Based on State

Use state to control function behavior:

```python
def conditional_process(step_input: StepInput, session_state: dict) -> StepOutput:
    # Check if initialized
    if not session_state.get("initialized", False):
        session_state["initialized"] = True
        session_state["setup_data"] = {"version": "1.0"}
        return StepOutput(content="Initialized")
    
    # Check counter threshold
    count = session_state.get("process_count", 0)
    
    if count >= 10:
        session_state["needs_reset"] = True
        return StepOutput(content="Threshold reached, needs reset")
    
    # Normal processing
    session_state["process_count"] = count + 1
    return StepOutput(content=f"Processed (count: {count + 1})")

workflow = Workflow(
    name="Conditional Processor",
    db=SqliteDb(db_file="conditional.db"),
    steps=[Step(name="Process", executor=conditional_process)],
    session_state={"initialized": False, "process_count": 0},
)
```

## Multi-Step State Sharing

Share data between multiple custom function steps:

```python
def step_one(step_input: StepInput, session_state: dict) -> StepOutput:
    # First step collects data
    data = step_input.input
    session_state["collected_data"] = data
    session_state["step_one_complete"] = True
    
    return StepOutput(content=f"Collected: {data}")

def step_two(step_input: StepInput, session_state: dict) -> StepOutput:
    # Second step processes data from step one
    data = session_state.get("collected_data", "No data")
    processed = f"Processed: {data}"
    
    session_state["processed_data"] = processed
    session_state["step_two_complete"] = True
    
    return StepOutput(content=processed)

def step_three(step_input: StepInput, session_state: dict) -> StepOutput:
    # Third step uses results from both previous steps
    collected = session_state.get("collected_data", "")
    processed = session_state.get("processed_data", "")
    
    result = f"Final: {collected} -> {processed}"
    session_state["final_result"] = result
    
    return StepOutput(content=result)

workflow = Workflow(
    name="Multi-Step Pipeline",
    db=SqliteDb(db_file="pipeline.db"),
    steps=[
        Step(name="Collect", executor=step_one),
        Step(name="Process", executor=step_two),
        Step(name="Finalize", executor=step_three),
    ],
    session_state={},
)
```

## Error Handling with State

Track errors and retry attempts:

```python
def resilient_processor(step_input: StepInput, session_state: dict) -> StepOutput:
    max_retries = 3
    retry_count = session_state.get("retry_count", 0)
    
    try:
        # Attempt processing
        result = process_data(step_input.input)  # Your logic here
        
        # Success - reset retry count
        session_state["retry_count"] = 0
        session_state["last_success"] = result
        
        return StepOutput(content=f"Success: {result}")
        
    except Exception as e:
        # Track failure
        retry_count += 1
        session_state["retry_count"] = retry_count
        session_state["last_error"] = str(e)
        
        if retry_count >= max_retries:
            session_state["failed_permanently"] = True
            return StepOutput(
                content=f"Failed after {max_retries} retries",
                success=False
            )
        else:
            return StepOutput(
                content=f"Retry {retry_count}/{max_retries}",
                success=False
            )

workflow = Workflow(
    name="Resilient Workflow",
    db=SqliteDb(db_file="resilient.db"),
    steps=[Step(name="Process", executor=resilient_processor)],
    session_state={"retry_count": 0},
)
```

## Best Practices

### Always Use .get() with Defaults

```python
# Good: Safe access with default
count = session_state.get("count", 0)

# Avoid: May raise KeyError
count = session_state["count"]
```

### Initialize State Keys

```python
# Good: Initialize in workflow
workflow = Workflow(
    session_state={
        "counter": 0,
        "items": [],
        "config": {},
    }
)

# Avoid: Relying on runtime initialization
def my_func(step_input, session_state):
    if "counter" not in session_state:
        session_state["counter"] = 0  # Better to initialize upfront
```

### Keep State Updates Atomic

```python
# Good: Complete update
items = session_state.get("items", [])
items.append(new_item)
session_state["items"] = items

# Avoid: In-place modification without reassignment
session_state.get("items", []).append(new_item)  # May not persist
```

## Troubleshooting

### State Changes Not Persisting

If modifications aren't saved:

1. Check function signature includes `session_state` parameter
2. Verify workflow has `db` configured
3. Ensure you're reassigning to the dict

```python
# Correct
def my_func(step_input: StepInput, session_state: dict) -> StepOutput:
    items = session_state.get("items", [])
    items.append("new")
    session_state["items"] = items  # âœ… Reassign
    return StepOutput(content="Done")
```

### State Not Available

If state is None or missing:

```python
def my_func(step_input: StepInput, session_state: dict) -> StepOutput:
    if session_state is None:
        return StepOutput(content="No state available", success=False)
    
    # Use state...
    return StepOutput(content="Success")
```

## Related Topics

<CardGroup cols={2}>
  <Card title="Agent Tools" icon="wrench" href="/basics/sessions/workflow-sessions/session-state/usage/agent-tools">
    Access state from agent tools
  </Card>
  <Card title="Conditions & Routers" icon="code-branch" href="/basics/sessions/workflow-sessions/session-state/usage/conditions-routers">
    Use state in workflow control flow
  </Card>
</CardGroup>

