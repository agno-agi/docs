---
title: Search & Retrieval
description: Understand how agents intelligently search and retrieve information from knowledge bases to provide accurate, contextual responses.
---

When an agent needs information to answer a question or complete a task, it doesn't just dump all available knowledge into the prompt. Instead, it intelligently searches for and retrieves only the most relevant information. This process is the heart of what makes knowledge-powered agents so effective.

## How Agents Search Knowledge

Think of an agent's search process like a skilled researcher who knows exactly what information to look for and where to find it:

<Steps>
  <Step title="Query Analysis">
    The agent analyzes the user's question to understand what type of information would be helpful
  </Step>
  <Step title="Search Strategy">
    Based on the analysis, the agent formulates one or more search queries to find relevant content
  </Step>
  <Step title="Information Retrieval">
    The agent searches the knowledge base and retrieves the most relevant content chunks
  </Step>
  <Step title="Context Integration">
    The retrieved information is combined with the original question to generate a comprehensive response
  </Step>
</Steps>

## Agentic Search: The Smart Difference

What makes Agno's approach special is **Agentic Search** - the agent has full control over the search process:

<CardGroup cols={2}>
  <Card title="Automatic Decision Making" icon="brain">
    The agent decides when it needs additional information and when it can answer from its existing knowledge.
  </Card>
  <Card title="Smart Query Generation" icon="search">
    The agent formulates optimal search queries, often using different keywords than the original question.
  </Card>
  <Card title="Multi-Step Search" icon="repeat">
    If the first search doesn't provide enough information, the agent can search again with refined queries.
  </Card>
  <Card title="Context Synthesis" icon="puzzle-piece">
    The agent combines information from multiple sources to provide comprehensive answers.
  </Card>
</CardGroup>

### Traditional RAG vs. Agentic RAG

<Tabs>
  <Tab title="Traditional RAG">
    ```python
    # Static approach - searches for everything
    user_query = "What's our return policy?"

    # Always searches, uses exact query
    search_results = vector_db.search(user_query)

    # Uses whatever is found
    response = llm.generate(user_query + search_results)
    ```
    **Limitations:**
    - Searches even when not needed
    - Uses user's exact words (may miss relevant content)
    - No ability to refine or follow up
  </Tab>
  <Tab title="Agentic RAG">
    ```python
    # Agent decides when and how to search
    user_query = "What's our return policy?"

    # Agent determines: "I need policy information"
    # Agent generates: "return policy, refund procedures, exchange rules"
    if agent.needs_knowledge(user_query):
        search_query = agent.generate_search_query(user_query)
        results = knowledge.search(search_query)

        # Agent can search again if needed
        if agent.needs_more_info(results):
            additional_results = knowledge.search(refined_query)

    response = agent.synthesize_response(user_query, all_results)
    ```
    **Benefits:**
    - Only searches when helpful
    - Uses optimal search terms
    - Can perform multiple searches
    - Intelligent result synthesis
  </Tab>
</Tabs>

## Types of Search Strategies

Agno supports multiple search approaches, and agents can use the most appropriate one for their needs:

### Vector Similarity Search
Finds content based on semantic meaning rather than exact keyword matches.

**How it works:**
- User query is converted to an embedding vector
- System finds content with similar embedding vectors
- Results are ranked by similarity score

**Best for:**
- Conceptual questions ("How do I improve performance?")
- Questions using different terminology than the source material
- Finding related but not identical information

### Keyword Search
Traditional text search that looks for exact word matches.

**How it works:**
- System searches for specific words and phrases
- Results are ranked by relevance and frequency
- Supports boolean operators and exact phrases

**Best for:**
- Finding specific terms, names, or identifiers
- Technical documentation with precise terminology
- Cases where exact word matching is important

### Hybrid Search
Combines vector similarity and keyword search for the best of both approaches.

**How it works:**
- Performs both vector and keyword searches simultaneously
- Combines and reranks results using sophisticated algorithms
- Often includes reranking models for optimal result ordering

**Best for:**
- Most production use cases
- Complex queries that benefit from both approaches
- Maximum accuracy and recall

<Tip>
We recommend using **hybrid search with reranking** for the best search quality. This approach combines the semantic understanding of vector search with the precision of keyword search.
</Tip>

## Search Quality Factors

Several factors influence how well agents can find and use information:

### Content Chunking Strategy
How your content is broken down affects search precision:

- **Smaller chunks**: More precise retrieval, but may lose context
- **Larger chunks**: Better context preservation, but less precise matching
- **Semantic chunking**: Respects natural content boundaries for optimal balance

### Embedding Model Quality
The model used to create vector embeddings impacts search understanding:

- **General models**: Good for broad content types
- **Domain-specific models**: Better for specialized content (legal, medical, technical)
- **Multilingual models**: Essential for non-English content

### Search Parameters
Fine-tuning search behavior for your use case:

```python
# Configure search behavior
knowledge = Knowledge(
    vector_db=vector_db,
    max_results=5,        # Number of chunks to retrieve
    similarity_threshold=0.7,  # Minimum relevance score
    reranker=CohereReranker()  # Improve result ordering
)
```

## Optimizing Search Results

### Improving Search Quality

**Add Rich Metadata:**
```python
knowledge.add_content(
    path="policies/",
    meta_data={"type": "policy", "department": "HR", "audience": "employees"}
)
```

**Use Descriptive Filenames:**
```python
# Better search results with clear naming
"hr_employee_handbook_2024.pdf"  # ✅ Clear and descriptive
"document1.pdf"                  # ❌ Generic and unhelpful
```

**Structure Content Logically:**
- Use clear headings and sections
- Include relevant keywords naturally
- Add summaries and abstracts
- Cross-reference related topics

### Monitoring Search Performance

**Test with Real Queries:**
```python
# Test search quality with actual questions
test_queries = [
    "What's our vacation policy?",
    "How do I submit expenses?",
    "Remote work guidelines"
]

for query in test_queries:
    results = knowledge.search(query)
    print(f"Query: {query}")
    print(f"Top result: {results[0]['content'][:100]}...")
```

**Analyze Retrieved Content:**
- Are the results relevant to the query?
- Is important information being missed?
- Are results ranked in the right order?
- Do you need to adjust chunking or search parameters?

## Advanced Search Features

### Custom Search Logic
For specialized search requirements:

```python
def custom_search_logic(query: str, knowledge: Knowledge) -> List[Dict]:
    # Apply business rules
    if "confidential" in query.lower():
        # Filter to only public information
        return knowledge.search(query, filters={"classification": "public"})

    # Use different search strategies based on query type
    if query.startswith("How to"):
        # Prioritize procedural content
        return knowledge.search(query, content_type="procedure")

    return knowledge.search(query)
```

### Search with Filtering
Restrict search to specific content subsets:

```python
# Search within specific categories
results = knowledge.search(
    "deployment process",
    filters={"department": "engineering", "type": "documentation"}
)

# Search by date range
results = knowledge.search(
    "quarterly results",
    filters={"created_after": "2024-01-01"}
)
```

### Multi-Modal Search
Search across different types of content:

```python
# Search text and extracted image content
knowledge.add_content(
    path="presentations/",
    extract_images=True,  # OCR text from images
    extract_tables=True   # Parse table content
)
```

## Best Practices for Search & Retrieval

### Content Strategy
- **Organize logically**: Group related content together
- **Use consistent terminology**: Maintain vocabulary across documents
- **Include context**: Add background information and cross-references
- **Update regularly**: Keep content current and remove outdated information

### Technical Optimization
- **Choose appropriate chunk sizes**: Test different sizes for your content type
- **Select quality embedders**: Use models that understand your domain
- **Configure hybrid search**: Combine vector and keyword search for best results
- **Implement reranking**: Use reranking models to improve result ordering

### Monitoring and Improvement
- **Test search quality**: Regularly test with real user queries
- **Analyze agent behavior**: Monitor what information agents retrieve
- **Gather feedback**: Track when agents can't find needed information
- **Iterate on strategy**: Continuously refine your approach based on results

## Next Steps

<CardGroup cols={2}>
  <Card title="Content Database" icon="database" href="/concepts/knowledge/content_db">
    Learn how content metadata is tracked and managed
  </Card>
  <Card title="Vector Databases" icon="vector-square" href="/concepts/knowledge/vectordb/introduction">
    Explore storage options for your knowledge base
  </Card>
  <Card title="Hybrid Search" icon="search" href="/concepts/knowledge/hybrid_search">
    Deep dive into advanced search strategies
  </Card>
  <Card title="Performance Tips" icon="zap" href="/concepts/knowledge/advanced/performance-tips">
    Optimize your knowledge base for speed and accuracy
  </Card>
</CardGroup>