---
title: Advanced Filtering
description: Understand how to add filter expressions to your Knowledge search requests.
keywords: [search, retrieval, rag, agentic rag, agentic search, search, filters, metadata]
---

When agents search through knowledge bases, sometimes you need more control than just "find similar content." Maybe you want to search only within specific documents, exclude outdated information, or focus on content from particular sources. That's where advanced filtering comes in‚Äîit lets you precisely target which content gets retrieved.

## How Knowledge Filtering Works

Think of filtering like adding smart constraints to a library search. Instead of searching through every book, you can tell the librarian: "Only look in the science section, published after 2020, but exclude textbooks." Knowledge filtering works the same way‚Äîyou specify criteria based on the metadata attached to your content.

<Steps>
  <Step title="Metadata Assignment">
    When you add content, attach metadata like department, document type, date, or any custom attributes.
  </Step>
  <Step title="Filter Construction">
    Build filter expressions using comparison and logical operators to define your search criteria.
  </Step>
  <Step title="Targeted Search">
    The knowledge base only searches through content that matches your filter conditions.
  </Step>
  <Step title="Contextual Results">
    You get precisely the information you need from exactly the right sources.
  </Step>
</Steps>

## Available Filter Expressions

Agno provides a rich set of filter expressions that can be combined to create sophisticated search criteria:

### Comparison Operators

These operators let you match against specific values:

#### EQ (Equals)
Match content where a metadata field equals a specific value.

```python
from agno.filters import EQ

# Find only HR policy documents
EQ("department", "hr")

# Find content from a specific year
EQ("year", 2024)
```

#### IN (Contains Any)
Match content where a metadata field contains any of the specified values.

```python
from agno.filters import IN

# Find content from multiple regions
IN("region", ["north_america", "europe", "asia"])

# Find multiple document types
IN("document_type", ["policy", "guideline", "procedure"])
```

#### GT (Greater Than) & LT (Less Than)
Match content based on numeric comparisons.

```python
from agno.filters import GT, LT

# Find recent documents
GT("year", 2020)

# Find documents with high priority scores
GT("priority_score", 8.0)

# Find documents within a date range
LT("year", 2025)
```

### Logical Operators

Combine multiple conditions using logical operators:

#### AND
All conditions must be true.

```python
from agno.filters import AND, EQ

# Find sales documents from North America in 2024
AND(
    EQ("data_type", "sales"),
    EQ("region", "north_america"),
    EQ("year", 2024)
)
```

#### OR  
At least one condition must be true.

```python
from agno.filters import OR, EQ

# Find either engineering or product documents
OR(
    EQ("department", "engineering"),
    EQ("department", "product")
)
```

#### NOT
Exclude content that matches the condition.

```python
from agno.filters import NOT, EQ

# Find everything except draft documents
NOT(EQ("status", "draft"))
```


## Using Filters with Agents

Here's how to apply filters when running agents with knowledge:

### Basic Agent Filtering

```python
from agno.agent import Agent
from agno.filters import EQ, IN, AND
from agno.knowledge.knowledge import Knowledge
from agno.vectordb.pgvector import PgVector

# Setup knowledge with metadata
knowledge = Knowledge(
    vector_db=PgVector(
        table_name="filtered_knowledge",
        db_url="postgresql+psycopg://ai:ai@localhost:5532/ai"
    )
)

# Add content with rich metadata
knowledge.add_content(
    path="sales_report_q1.csv",
    metadata={
        "data_type": "sales",
        "quarter": "Q1", 
        "year": 2024,
        "region": "north_america",
        "currency": "USD"
    }
)

# Create agent with knowledge
sales_agent = Agent(
    knowledge=knowledge,
    search_knowledge=True,
    instructions="Always search knowledge before answering questions"
)

# Use filters in agent responses - NOTE: filters must be in a list!
sales_agent.print_response(
    "What were our Q1 sales results?",
    knowledge_filters=[  # ‚Üê Must be a list!
        AND(EQ("data_type", "sales"), EQ("quarter", "Q1"))
    ]
)
```

### Complex Filter Examples

```python
from agno.filters import AND, OR, NOT, EQ, IN, GT

# Find recent sales data from specific regions, but exclude drafts
complex_filter = AND(
    EQ("data_type", "sales"),
    IN("region", ["north_america", "europe"]),  
    GT("year", 2022),
    NOT(EQ("status", "draft"))
)

# Search for either customer feedback or survey data from the last two years
feedback_filter = AND(
    OR(
        EQ("data_type", "feedback"),
        EQ("data_type", "survey")
    ),
    GT("year", 2022)
)

agent.print_response(
    "What do our customers think about our new features?",
    knowledge_filters=[feedback_filter]  # ‚Üê List wrapper required
)
```

## Using Filters with Teams

Teams can also leverage filtered knowledge searches:

```python
from agno.team.team import Team
from agno.agent import Agent
from agno.filters import IN, AND, NOT, EQ

# Setup team members
research_agent = Agent(
    name="Research Agent",
    role="Analyze candidate information",
    knowledge=knowledge_base
)

# Create team with knowledge
hiring_team = Team(
    name="Hiring Team",
    members=[research_agent],
    knowledge=knowledge_base,
    instructions="Analyze candidate profiles thoroughly"
)

# Filter to specific candidates
hiring_team.print_response(
    "Compare the experience of our top candidates",
    knowledge_filters=[  # ‚Üê List wrapper required
        AND(
            EQ("document_type", "cv"),
            IN("user_id", ["jordan_mitchell", "taylor_brooks"]),
            NOT(EQ("status", "rejected"))
        )
    ]
)
```

## Advanced Filtering Patterns

### User-Specific Content

Filter content based on user access or preferences:

```python
from agno.filters import OR, EQ

def get_user_filter(user_id: str, user_department: str):
    """Create filters based on user context."""
    return OR(
        EQ("visibility", "public"),
        EQ("owner", user_id),
        EQ("department", user_department)
    )

# Apply user-specific filtering
user_filter = get_user_filter("john_doe", "engineering")
agent.print_response(
    "Show me the latest project updates",
    knowledge_filters=[user_filter]  # ‚Üê List wrapper required
)
```

### Time-Based Filtering

Filter by recency or date ranges:

```python
from datetime import datetime
from agno.filters import AND, NOT, EQ, GT

current_year = datetime.now().year

# Only search recent content
recent_filter = GT("year", current_year - 2)

# Exclude archived content
active_filter = NOT(EQ("status", "archived"))

# Combine for active, recent content
current_content = AND(recent_filter, active_filter)

# Use in agent - wrap in list
agent.print_response(
    "What's new?",
    knowledge_filters=[current_content]
)
```

### Progressive Filtering

Start broad, then narrow down based on results:

```python
from agno.filters import AND, EQ, GT

async def progressive_search(agent, query, base_filters=None):
    """Try broad search first, then narrow if too many results."""
    
    # First attempt: broad search
    broad_results = await agent.aget_relevant_docs_from_knowledge(
        query=query,
        filters=base_filters,  # Already a list
        num_documents=10
    )
    
    if len(broad_results) > 8:
        # Too many results, add more specific filters
        specific_filter = AND(
            base_filters[0] if base_filters else EQ("status", "active"),
            GT("relevance_score", 0.8)
        )
        
        return await agent.aget_relevant_docs_from_knowledge(
            query=query,
            filters=[specific_filter],  # ‚Üê Wrapped in list
            num_documents=5
        )
    
    return broad_results
```

## Working with Metadata

### Designing Effective Metadata

Good filtering starts with thoughtful metadata design:

```python
# ‚úÖ Rich, searchable metadata
good_metadata = {
    "document_type": "policy",
    "department": "hr", 
    "category": "benefits",
    "audience": "all_employees",
    "last_updated": "2024-01-15",
    "version": "2.1",
    "tags": ["health_insurance", "401k", "vacation"],
    "sensitivity": "internal"
}

# ‚ùå Sparse, hard to filter metadata  
poor_metadata = {
    "type": "doc",
    "id": "12345"
}
```

### Dynamic Metadata Assignment

Add metadata programmatically based on content:

```python
def assign_metadata(file_path: str) -> dict:
    """Generate metadata based on file characteristics."""
    metadata = {}
    
    # Extract from filename
    if "policy" in file_path.lower():
        metadata["document_type"] = "policy"
    elif "guide" in file_path.lower():
        metadata["document_type"] = "guide"
    
    # Extract department from path
    if "/hr/" in file_path:
        metadata["department"] = "hr"
    elif "/engineering/" in file_path:
        metadata["department"] = "engineering"
    
    # Add timestamp
    metadata["indexed_at"] = datetime.now().isoformat()
    
    return metadata

# Use when adding content
for file_path in document_files:
    knowledge.add_content(
        path=file_path,
        metadata=assign_metadata(file_path)
    )
```

## Best Practices for Advanced Filtering

### Metadata Strategy

- **Be Consistent**: Use standardized values (e.g., always "hr" not sometimes "HR" or "human_resources")
- **Think Hierarchically**: Use nested categories when appropriate (`department.team`, `location.region`)
- **Include Temporal Data**: Add dates, versions, or other time-based metadata for lifecycle management
- **Add Semantic Tags**: Include searchable tags or keywords that might not appear in the content

### Filter Design

- **Start Simple**: Begin with basic filters and add complexity as needed
- **Test Combinations**: Verify that your logical combinations work as expected
- **Document Your Schema**: Keep track of available metadata fields and their possible values
- **Performance Considerations**: Some filter combinations may be slower than others

### Error Handling

```python
def safe_filter_search(agent, query, filters):
    """Safely apply filters with fallback to unfiltered search."""
    try:
        # Try filtered search first (filters should already be a list)
        results = agent.get_relevant_docs_from_knowledge(
            query=query,
            filters=filters,  # Pass as-is if already a list
            num_documents=5
        )
        
        if not results:
            # Fall back to unfiltered search
            print("No results with filters, trying broader search...")
            results = agent.get_relevant_docs_from_knowledge(
                query=query,
                num_documents=10
            )
        
        return results
        
    except Exception as e:
        print(f"Filter error: {e}, falling back to basic search")
        return agent.get_relevant_docs_from_knowledge(query=query)
```

### Vector Database Support

Advanced filter expressions (using `FilterExpr` like `EQ()`, `AND()`, etc.) have varying support across vector databases:

| Vector DB | Dictionary Filters `{"key": "value"}` | FilterExpr `EQ()`, `AND()`, etc. |
|-----------|--------------------------------------|----------------------------------|
| **PgVector** | ‚úÖ Full support | ‚úÖ Full support (native) |
| **LanceDB** | ‚úÖ Post-search filtering | ‚ö†Ô∏è Not yet supported* |
| **ChromaDB** | ‚úÖ Full support | ‚ö†Ô∏è Not yet supported |
| **Pinecone** | ‚úÖ Full support | ‚ö†Ô∏è Not yet supported |
| **Qdrant** | ‚úÖ Full support | ‚ö†Ô∏è Not yet supported |

<Note>
**What happens with unsupported FilterExpr:**

When using `FilterExpr` with unsupported vector databases:
- You'll see: `WARNING: Filter Expressions are not yet supported in [DatabaseName]. No filters will be applied.`
- Search proceeds without filters (unfiltered results)
- No errors thrown, but filtering is ignored

**Workaround:** Use dictionary format instead:
```python
# Works with all vector databases
knowledge_filters=[{"department": "hr", "year": 2024}]

# Only works with PgVector currently
knowledge_filters=[AND(EQ("department", "hr"), EQ("year", 2024))]
```
</Note>

**Coming Soon:**
- üîÑ LanceDB FilterExpr support (in development)
- üîÑ ChromaDB FilterExpr support (planned)  
- üîÑ Pinecone FilterExpr support (planned)
- üîÑ Universal FilterExpr support across all vector databases

### Agentic Filtering Compatibility

Advanced filter expressions (`FilterExpr`) are **not compatible with agentic filtering**, where agents dynamically construct filters based on conversation context.

**For agentic filtering, use dictionary format:**

```python
# ‚úÖ Works with agentic filtering (agent decides filters dynamically)
knowledge_filters = [{"department": "hr", "document_type": "policy"}]

# ‚ùå Does not work with agentic filtering (static, predefined logic)
knowledge_filters = [AND(EQ("department", "hr"), EQ("document_type", "policy"))]
```

**When to use each approach:**

| Approach | Use Case | Example |
|----------|----------|---------|
| **Dictionary format** | Agent dynamically chooses filters based on conversation | User mentions "HR policies" ‚Üí agent adds `{"department": "hr"}` |
| **Filter expressions** | You need complex, predetermined logic with full control | Always exclude drafts AND filter by multiple regions with OR logic |

**Hybrid Approach:**

If you need both agentic decision-making and complex filtering:

```python
from agno.filters import AND, EQ, GT, NOT

# Define filter presets
FILTER_PRESETS = {
    "recent_hr": [AND(EQ("department", "hr"), GT("year", 2023))],
    "active_engineering": [AND(EQ("department", "engineering"), NOT(EQ("status", "archived")))],
    "all_public": [EQ("visibility", "public")]
}

# Agent chooses which preset to use based on context
def get_filter_for_context(user_query: str):
    if "recent" in user_query.lower() and "hr" in user_query.lower():
        return FILTER_PRESETS["recent_hr"]
    # ... more logic
    return None
```


## Using Filters Through the API

All the filter expressions shown in this guide can also be used through the Agent OS API. FilterExpressions serialize to JSON and are automatically reconstructed server-side, enabling the same powerful filtering capabilities over REST endpoints.

```python
import requests
import json
from agno.filters import EQ, GT, AND

# Create filter expression
filter_expr = AND(EQ("status", "published"), GT("views", 1000))

# Serialize to JSON
filter_json = json.dumps(filter_expr.to_dict())

# Send through API
response = requests.post(
    "http://localhost:7777/agents/my-agent/runs",
    data={
        "message": "Find popular published articles",
        "stream": "false",
        "knowledge_filters": filter_json,
    }
)
```

<Note>
FilterExpressions use a dictionary format with an `"op"` key (e.g., `{"op": "EQ", "key": "status", "value": "published"}`) which tells the API to deserialize them as FilterExpr objects. Regular dict filters without the `"op"` key continue to work for backward compatibility.
</Note>

For detailed examples, API-specific patterns, and troubleshooting, see the [API Filtering Guide](/agent-os/customize/os/filter_knowledge).

## Next Steps

<CardGroup cols={2}>
  <Card
    title="API Filtering Guide" 
    icon="code"
    href="/agent-os/customize/os/filter_knowledge"
  >
    Use filter expressions through the Agent OS API
  </Card>
  <Card
    title="Search & Retrieval" 
    icon="magnifying-glass"
    href="/concepts/knowledge/core-concepts/search-retrieval"
  >
    Learn about different search strategies and optimization
  </Card>
  <Card
    title="Content Database"
    icon="database" 
    href="/concepts/knowledge/content_db"
  >
    Understand how content and metadata are stored and managed
  </Card>
  <Card
    title="Knowledge Bases"
    icon="book-open"
    href="/concepts/knowledge/core-concepts/knowledge-bases" 
  >
    Deep dive into knowledge base architecture and design
  </Card>
  <Card
    title="Performance Tips"
    icon="gauge"
    href="/concepts/knowledge/advanced/performance-tips"
  >
    Optimize your filtered searches for speed and accuracy
  </Card>
</CardGroup>