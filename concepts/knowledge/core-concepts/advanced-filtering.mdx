---
title: Advanced Filtering
description: Understand how to add filter expressions to your Knowledge search requests.
keywords: [search, retrieval, rag, agentic rag, agentic search, search, filters, metadata]
---

When agents search through knowledge bases, sometimes you need more control than just "find similar content." Maybe you want to search only within specific documents, exclude outdated information, or focus on content from particular sources. That's where advanced filtering comes in‚Äîit lets you precisely target which content gets retrieved.

## How Knowledge Filtering Works

Think of filtering like adding smart constraints to a library search. Instead of searching through every book, you can tell the librarian: "Only look in the science section, published after 2020, but exclude textbooks." Knowledge filtering works the same way‚Äîyou specify criteria based on the metadata attached to your content.

<Steps>
  <Step title="Metadata Assignment">
    When you add content, attach metadata like department, document type, date, or any custom attributes.
  </Step>
  <Step title="Filter Construction">
    Build filter expressions using comparison and logical operators to define your search criteria.
  </Step>
  <Step title="Targeted Search">
    The knowledge base only searches through content that matches your filter conditions.
  </Step>
  <Step title="Contextual Results">
    You get precisely the information you need from exactly the right sources.
  </Step>
</Steps>

## Available Filter Expressions

Agno provides a rich set of filter expressions that can be combined to create sophisticated search criteria:

### Comparison Operators

These operators let you match against specific values:

#### EQ (Equals)
Match content where a metadata field equals a specific value.

```python
from agno.knowledge.filters import EQ

# Find only HR policy documents
EQ("department", "hr")

# Find content from a specific year
EQ("year", 2024)
```

#### IN (Contains Any)
Match content where a metadata field contains any of the specified values.

```python
from agno.knowledge.filters import IN

# Find content from multiple regions
IN("region", ["north_america", "europe", "asia"])

# Find multiple document types
IN("document_type", ["policy", "guideline", "procedure"])
```

#### GT (Greater Than) & LT (Less Than)
Match content based on numeric comparisons.

```python
from agno.knowledge.filters import GT, LT

# Find recent documents
GT("year", 2020)

# Find documents with high priority scores
GT("priority_score", 8.0)

# Find documents within a date range
LT("year", 2025)
```

### Logical Operators

Combine multiple conditions using logical operators:

#### AND
All conditions must be true.

```python
from agno.knowledge.filters import AND, EQ

# Find sales documents from North America in 2024
AND(
    EQ("data_type", "sales"),
    EQ("region", "north_america"),
    EQ("year", 2024)
)
```

#### OR  
At least one condition must be true.

```python
from agno.knowledge.filters import OR, EQ

# Find either engineering or product documents
OR(
    EQ("department", "engineering"),
    EQ("department", "product")
)
```

#### NOT
Exclude content that matches the condition.

```python
from agno.knowledge.filters import NOT, EQ

# Find everything except draft documents
NOT(EQ("status", "draft"))
```


## Using Filters with Agents

Here's how to apply filters when running agents with knowledge:

### Basic Agent Filtering

```python
from agno.agent import Agent
from agno.knowledge.filters import EQ, IN
from agno.knowledge.knowledge import Knowledge
from agno.vectordb.pgvector import PgVector

# Setup knowledge with metadata
knowledge = Knowledge(
    vector_db=PgVector(
        table_name="filtered_knowledge",
        db_url="postgresql+psycopg://ai:ai@localhost:5532/ai"
    )
)

# Add content with rich metadata
knowledge.add_content(
    path="sales_report_q1.csv",
    metadata={
        "data_type": "sales",
        "quarter": "Q1", 
        "year": 2024,
        "region": "north_america",
        "currency": "USD"
    }
)

# Create agent with knowledge
sales_agent = Agent(
    knowledge=knowledge,
    search_knowledge=True,
    instructions="Always search knowledge before answering questions"
)

# Use filters in agent responses
sales_agent.print_response(
    "What were our Q1 sales results?",
    knowledge_filters=[
        AND(EQ("data_type", "sales"), EQ("quarter", "Q1"))
    ]
)
```

### Complex Filter Examples

```python
from agno.knowledge.filters import AND, OR, NOT, EQ, IN, GT

# Find recent sales data from specific regions, but exclude drafts
complex_filter = AND(
    EQ("data_type", "sales"),
    IN("region", ["north_america", "europe"]),  
    GT("year", 2022),
    NOT(EQ("status", "draft"))
)

# Search for either customer feedback or survey data from the last two years
feedback_filter = AND(
    OR(
        EQ("data_type", "feedback"),
        EQ("data_type", "survey")
    ),
    GT("year", 2022)
)

agent.print_response(
    "What do our customers think about our new features?",
    knowledge_filters=[feedback_filter]
)
```

## Using Filters with Teams

Teams can also leverage filtered knowledge searches:

```python
from agno.team.team import Team
from agno.agent import Agent
from agno.knowledge.filters import IN, AND, NOT

# Setup team members
research_agent = Agent(
    name="Research Agent",
    role="Analyze candidate information",
    knowledge=knowledge_base
)

# Create team with knowledge
hiring_team = Team(
    name="Hiring Team",
    members=[research_agent],
    knowledge=knowledge_base,
    instructions="Analyze candidate profiles thoroughly"
)

# Filter to specific candidates
hiring_team.print_response(
    "Compare the experience of our top candidates",
    knowledge_filters=[
        AND(
            EQ("document_type", "cv"),
            IN("user_id", ["jordan_mitchell", "taylor_brooks"]),
            NOT(EQ("status", "rejected"))
        )
    ]
)
```

## Advanced Filtering Patterns

### User-Specific Content

Filter content based on user access or preferences:

```python
def get_user_filter(user_id: str, user_department: str):
    """Create filters based on user context."""
    return OR(
        EQ("visibility", "public"),
        EQ("owner", user_id),
        EQ("department", user_department)
    )

# Apply user-specific filtering
user_filter = get_user_filter("john_doe", "engineering")
agent.print_response(
    "Show me the latest project updates",
    knowledge_filters=[user_filter]
)
```

### Time-Based Filtering

Filter by recency or date ranges:

```python
from datetime import datetime
from agno.knowledge.filters import AND, NOT, EQ, GT

current_year = datetime.now().year

# Only search recent content
recent_filter = GT("year", current_year - 2)

# Exclude archived content
active_filter = NOT(EQ("status", "archived"))

# Combine for active, recent content
current_content = AND(recent_filter, active_filter)
```

### Progressive Filtering

Start broad, then narrow down based on results:

```python
async def progressive_search(agent, query, base_filters=None):
    """Try broad search first, then narrow if too many results."""
    
    # First attempt: broad search
    broad_results = await agent.aget_relevant_docs_from_knowledge(
        query=query,
        filters=base_filters,
        num_documents=10
    )
    
    if len(broad_results) > 8:
        # Too many results, add more specific filters
        specific_filter = AND(
            base_filters[0] if base_filters else EQ("status", "active"),
            GT("relevance_score", 0.8)
        )
        
        return await agent.aget_relevant_docs_from_knowledge(
            query=query,
            filters=[specific_filter],
            num_documents=5
        )
    
    return broad_results
```

## Working with Metadata

### Designing Effective Metadata

Good filtering starts with thoughtful metadata design:

```python
# ‚úÖ Rich, searchable metadata
good_metadata = {
    "document_type": "policy",
    "department": "hr", 
    "category": "benefits",
    "audience": "all_employees",
    "last_updated": "2024-01-15",
    "version": "2.1",
    "tags": ["health_insurance", "401k", "vacation"],
    "sensitivity": "internal"
}

# ‚ùå Sparse, hard to filter metadata  
poor_metadata = {
    "type": "doc",
    "id": "12345"
}
```

### Dynamic Metadata Assignment

Add metadata programmatically based on content:

```python
def assign_metadata(file_path: str) -> dict:
    """Generate metadata based on file characteristics."""
    metadata = {}
    
    # Extract from filename
    if "policy" in file_path.lower():
        metadata["document_type"] = "policy"
    elif "guide" in file_path.lower():
        metadata["document_type"] = "guide"
    
    # Extract department from path
    if "/hr/" in file_path:
        metadata["department"] = "hr"
    elif "/engineering/" in file_path:
        metadata["department"] = "engineering"
    
    # Add timestamp
    metadata["indexed_at"] = datetime.now().isoformat()
    
    return metadata

# Use when adding content
for file_path in document_files:
    knowledge.add_content(
        path=file_path,
        metadata=assign_metadata(file_path)
    )
```

## Best Practices for Advanced Filtering

### Metadata Strategy

- **Be Consistent**: Use standardized values (e.g., always "hr" not sometimes "HR" or "human_resources")
- **Think Hierarchically**: Use nested categories when appropriate (`department.team`, `location.region`)
- **Include Temporal Data**: Add dates, versions, or other time-based metadata for lifecycle management
- **Add Semantic Tags**: Include searchable tags or keywords that might not appear in the content

### Filter Design

- **Start Simple**: Begin with basic filters and add complexity as needed
- **Test Combinations**: Verify that your logical combinations work as expected
- **Document Your Schema**: Keep track of available metadata fields and their possible values
- **Performance Considerations**: Some filter combinations may be slower than others

### Error Handling

```python
def safe_filter_search(agent, query, filters):
    """Safely apply filters with fallback to unfiltered search."""
    try:
        # Try filtered search first
        results = agent.get_relevant_docs_from_knowledge(
            query=query,
            filters=filters,
            num_documents=5
        )
        
        if not results:
            # Fall back to unfiltered search
            print("No results with filters, trying broader search...")
            results = agent.get_relevant_docs_from_knowledge(
                query=query,
                num_documents=10
            )
        
        return results
        
    except Exception as e:
        print(f"Filter error: {e}, falling back to basic search")
        return agent.get_relevant_docs_from_knowledge(query=query)
```


## Current Limitations

### Vector Database Support

Advanced filter expressions are currently **only supported with PgVector**. If you're using other vector databases like ChromaDB, LanceDB, or Pinecone, filter expressions will not be applied.

**What happens with unsupported vector databases:**
- Filter expressions are silently ignored
- The system falls back to a broad, unfiltered search
- You'll still get results, but they won't respect your filtering criteria

**Supported:**
- ‚úÖ PgVector with PostgreSQL

**Coming Soon:**
- üîÑ ChromaDB support (planned)
- üîÑ LanceDB support (planned)  
- üîÑ Pinecone support (planned)
- üîÑ Other popular vector databases

### Agentic Filtering Compatibility

Advanced filter expressions are **not compatible with agentic filtering**, where agents dynamically decide what filters to apply during runtime based on the conversation context.

**For agentic filtering, use the original dictionary format:**

```python
# ‚úÖ Works with agentic filtering
knowledge_filters = [{"department": "hr", "document_type": "policy"}]

# ‚ùå Does not work with agentic filtering  
knowledge_filters = [AND(EQ("department", "hr"), EQ("document_type", "policy"))]
```

**When to use each approach:**

- **Dictionary format** (`{"key": "value"}`): Use when you want agents to dynamically decide filters based on conversation context
- **Filter expressions** (`EQ()`, `AND()`, etc.): Use when you need complex, predetermined filtering logic with full control

<Note>
If you need both agentic decision-making and complex filtering, consider implementing a hybrid approach where the agent chooses between predefined filter expression sets based on context.
</Note>


## Next Steps

<CardGroup cols={2}>
  <Card
    title="Search & Retrieval" 
    icon="magnifying-glass"
    href="/concepts/knowledge/core-concepts/search-retrieval"
  >
    Learn about different search strategies and optimization
  </Card>
  <Card
    title="Content Database"
    icon="database" 
    href="/concepts/knowledge/content_db"
  >
    Understand how content and metadata are stored and managed
  </Card>
  <Card
    title="Knowledge Bases"
    icon="book-open"
    href="/concepts/knowledge/core-concepts/knowledge-bases" 
  >
    Deep dive into knowledge base architecture and design
  </Card>
  <Card
    title="Performance Tips"
    icon="gauge"
    href="/concepts/knowledge/advanced/performance-tips"
  >
    Optimize your filtered searches for speed and accuracy
  </Card>
</CardGroup>