---
title: Custom Toolkits
sidebarTitle: Custom Toolkits
description: Learn how to write your own toolkits.
keywords: custom toolkits, toolkit class, tool collections, shared state, toolkit creation
---

A **Toolkit** is a collection of related tools that share state and configuration. Use toolkits when you have multiple tools that need to work together with shared resources like database connections, API clients, or working directories.

## Why Use Toolkits?

Toolkits provide several advantages over individual functions:
- **Shared state** - Tools can access common configuration and resources
- **Better organization** - Group related functionality together
- **Reusability** - Easily add the entire toolkit to multiple agents
- **Cleaner code** - Centralize setup and configuration

## Creating a Toolkit

Here's how to create a custom toolkit in three steps:

1. **Create a class** that inherits from `agno.tools.Toolkit`
2. **Add methods** for each tool you want to provide
3. **Register tools** by passing them to the `Toolkit` constructor

## Example: File System Toolkit

Let's create a toolkit that provides file system operations with a shared working directory:

```python file_system_toolkit.py
import os
from typing import List

from agno.agent import Agent
from agno.tools import Toolkit
from agno.utils.log import logger


class FileSystemTools(Toolkit):
    def __init__(self, working_directory: str = ".", **kwargs):
        """Initialize the file system toolkit.

        Args:
            working_directory: Base directory for all file operations
        """
        self.working_directory = os.path.abspath(working_directory)

        # Register all tools with the toolkit
        super().__init__(
            name="file_system_tools",
            tools=[self.list_files, self.run_command],
            **kwargs
        )

    def list_files(self, directory: str = ".") -> str:
        """List all files and directories in the specified path.

        Args:
            directory: Directory path relative to working directory. Defaults to current directory.

        Returns:
            str: Newline-separated list of files and directories.
        """
        path = os.path.join(self.working_directory, directory)
        try:
            files = os.listdir(path)
            return "\n".join(sorted(files))
        except Exception as e:
            logger.warning(f"Failed to list files in {path}: {e}")
            return f"Error: {e}"

    def run_command(self, args: List[str], tail: int = 100) -> str:
        """Execute a shell command in the working directory.

        Args:
            args: Command and arguments as a list (e.g., ["ls", "-la"])
            tail: Number of output lines to return (default: 100)

        Returns:
            str: Command output or error message.
        """
        import subprocess

        logger.info(f"Running command: {' '.join(args)}")
        try:
            result = subprocess.run(
                args,
                capture_output=True,
                text=True,
                cwd=self.working_directory
            )

            if result.returncode != 0:
                return f"Error: {result.stderr}"

            # Return only the last N lines
            lines = result.stdout.split("\n")
            return "\n".join(lines[-tail:])
        except Exception as e:
            logger.warning(f"Failed to run command: {e}")
            return f"Error: {e}"


# Example: Create an agent with the file system toolkit
agent = Agent(
    tools=[FileSystemTools(working_directory=os.path.expanduser("~"))],
    markdown=True
)

agent.print_response("List all the files in the current directory.")
```

### Key Points

**Shared State:**
The `working_directory` is set once during initialization and shared by all tools in the toolkit. This demonstrates how toolkits can maintain state across multiple tool calls.

**Tool Registration:**
Notice how both `self.list_files` and `self.run_command` are passed to the `tools` parameter in the `super().__init__()` call. This registers them as callable tools for the agent.

**Descriptive Docstrings:**
Each tool has a clear docstring explaining what it does, its parameters, and return values. The LLM uses these docstrings to understand when and how to call each tool.

<Note>
**Best Practices:**
- Use descriptive method names that clearly indicate what the tool does
- Write detailed docstrings - the LLM uses these to understand your tools
- Handle errors gracefully and return helpful error messages
- Keep tools focused on a single responsibility
</Note>

## When to Use Toolkits vs Functions

Use a **Toolkit** when:
- You have 4+ related tools that work together
- Tools need to share state (connections, configuration, etc.)
- You want to reuse the same set of tools across multiple agents

Use **Python Functions** when:
- You have 1-3 simple, independent tools
- Tools don't need to share any state
- You want the quickest implementation

See the [Python Functions vs Toolkits comparison](/concepts/tools/creating-tools/overview) for more details.

<Card title="Toolkit Reference" icon="book" href="/reference/tools/toolkit">
  View the complete Toolkit API reference
</Card>

## Learn more

<CardGroup cols={3}>
  <Card
    title="Python Functions"
    icon="function"
    iconType="duotone"
    href="/concepts/tools/creating-tools/python-functions"
  >
    Learn when to use functions vs toolkits
  </Card>
  <Card
    title="Tool Hooks"
    icon="webhook"
    iconType="duotone"
    href="/concepts/tools/hooks"
  >
    Add validation and logging to your toolkit tools
  </Card>
  <Card
    title="Available Toolkits"
    icon="box-open"
    iconType="duotone"
    href="/concepts/tools/toolkits"
  >
    Explore 120+ pre-built toolkits as examples
  </Card>
</CardGroup>