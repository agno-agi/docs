---
title: Tool Call Limit
sidebarTitle: Tool Call Limit
description: Learn to limit the number of tool calls an agent can make.
keywords: tool call limit, rate limiting, cost control, performance, loop prevention
---

Limiting the number of tool calls an Agent can make is useful to prevent loops and have better control over costs and performance.

## When to Use Tool Call Limits

Set a `tool_call_limit` when you need to:

- **Prevent infinite loops** - Stop agents from getting stuck in tool call cycles
- **Control costs** - Limit expensive API calls or compute resources
- **Enforce task boundaries** - Keep agents focused on simple, constrained tasks
- **Testing and debugging** - Quickly test agent behavior without long execution times
- **Production safety** - Add guardrails to prevent runaway costs

**Common scenarios:**
- Simple lookup tasks that should only call 1-2 tools
- Demo or sandbox environments with strict limits
- Cost-sensitive applications where tool calls are expensive
- Agents with complex tool sets where loops are likely

## Usage

Setting a tool call limit is simple - just pass the `tool_call_limit` parameter when initializing your Agent or Team:

For example:

```python
from agno.agent import Agent
from agno.models.openai.chat import OpenAIChat
from agno.tools.yfinance import YFinanceTools

agent = Agent(
    model=OpenAIChat(id="gpt-5-mini"),
    tools=[YFinanceTools(company_news=True, cache_results=True)],
    tool_call_limit=1, # The Agent will not perform more than one tool call.
)

# The first tool call will be performed. The second one will fail gracefully.
agent.print_response(
    "Find me the current price of TSLA, then after that find me the latest news about Tesla.",
    stream=True,
)

```

<Tip>
Important to consider:
- If the Agent tries to run a number of tool calls that exceeds the limit **all at once**, the limit will remain effective. Only as many tool calls as allowed will be performed.
- The limit is enforced **across a full run**, and not per individual requests triggered by the Agent.
</Tip>

## Troubleshooting

**Problem: Agent stops mid-task without completing**
- **Cause**: Tool call limit set too low for the task complexity
- **Solution**: Increase `tool_call_limit` or simplify the task. Monitor logs to see how many tool calls are actually needed.

**Problem: Agent still making too many calls across multiple runs**
- **Cause**: Limit is per-run, not cumulative
- **Solution**: Each `agent.print_response()` or `agent.run()` call gets the full limit. If you need to limit across multiple runs, track calls manually.

**Problem: How do I know what limit to set?**
- **Solution**:
  1. Run without a limit and check logs to see actual tool call count
  2. Set limit to ~150% of typical usage to allow some flexibility
  3. Monitor and adjust based on real usage patterns

**Problem: Need different limits for different tasks**
- **Solution**: Create separate agent instances with different limits for different task types, or adjust the limit dynamically using `agent.tool_call_limit = new_limit` before each run.

## Learn more

<CardGroup cols={3}>
  <Card
    title="Exceptions & Retries"
    icon="rotate-right"
    iconType="duotone"
    href="/concepts/tools/exceptions"
  >
    Handle tool failures and retry logic
  </Card>
  <Card
    title="Tool Hooks"
    icon="webhook"
    iconType="duotone"
    href="/concepts/tools/hooks"
  >
    Add custom logic before and after tool calls
  </Card>
  <Card
    title="Selecting Tools"
    icon="filter"
    iconType="duotone"
    href="/concepts/tools/selecting-tools"
  >
    Control which tools agents can access
  </Card>
</CardGroup>