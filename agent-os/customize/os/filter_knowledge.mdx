---
title: Knowledge Filtering
description: Learn how to use advanced filter expressions through the Agno API for precise knowledge base filtering.
keywords: [api, filtering, filterexpr, knowledge, search, rest api]
---

When using the AgentOS API, you can apply advanced filter expressions to precisely control which knowledge base documents your agents search. Filter expressions serialize to JSON and are automatically reconstructed server-side for powerful, programmatic filtering.

## Overview

Filter expressions provide a composable way to filter knowledge using complex logical conditions through HTTP APIs. They offer the same power as Python-based filtering but work seamlessly over REST endpoints.

<CardGroup cols={2}>
  <Card title="Comparison Operators" icon="equals">
    EQ, GT, LT, IN for matching values
  </Card>
  <Card title="Logical Operators" icon="diagram-project">
    AND, OR, NOT for combining conditions
  </Card>
  <Card title="JSON Serialization" icon="code">
    Automatic conversion to/from JSON
  </Card>
  <Card title="Backward Compatible" icon="check">
    Dict-based filters still work
  </Card>
</CardGroup>

## Filter Operators

### Comparison Operators

- **`EQ(key, value)`** - Equality: field equals value
- **`GT(key, value)`** - Greater than: field > value  
- **`LT(key, value)`** - Less than: field < value
- **`IN(key, [values])`** - Inclusion: field in list of values

### Logical Operators

- **`AND(*filters)`** - All conditions must be true
- **`OR(*filters)`** - At least one condition must be true
- **`NOT(filter)`** - Negate a condition

## Serialization Format

Filter expression objects use a dictionary format with an `"op"` key that distinguishes them from regular dict filters:

```python
from agno.filters import EQ, GT, AND

# Python filter expression
filter_expr = AND(EQ("status", "published"), GT("views", 1000))

# Serialized to JSON
{
  "op": "AND",
  "conditions": [
    {"op": "EQ", "key": "status", "value": "published"},
    {"op": "GT", "key": "views", "value": 1000}
  ]
}
```

<Note>
The presence of the `"op"` key tells the API to deserialize the filter as a filter expression. Regular dict filters (without `"op"`) continue to work for backward compatibility.
</Note>

## Two Approaches to Filtering

Agno supports two ways to filter knowledge through the API:

### 1. Dictionary Filters (Simple)

Best for straightforward equality matching. Send a JSON object with key-value pairs:

```json
{"docs": "agno", "status": "published"}
```

**Pros:**
- Simple and intuitive
- Great for basic filtering
- Works with all vector databases
- Less verbose

**Cons:**
- Only supports AND logic (all conditions must match)
- Only equality matching (no GT, LT, etc.)
- Cannot nest conditions or use OR/NOT

### 2. Filter Expressions (Advanced)

Best for complex filtering with full logical control. Send structured filter objects:

```json
{"op": "AND", "conditions": [
  {"op": "EQ", "key": "docs", "value": "agno"},
  {"op": "GT", "key": "version", "value": 2}
]}
```

**Pros:**
- Full logical operators (AND, OR, NOT)
- Comparison operators (EQ, GT, LT, IN)
- Complex nested conditions
- Precise control

**Cons:**
- More verbose
- Requires understanding filter structure
- Limited vector database support (PgVector fully supported)

<Tip>
**When to use which:**
- Use **dict filters** for simple queries like filtering by category or status
- Use **filter expressions** when you need OR logic, exclusions (NOT), or range queries (GT/LT)
</Tip>

## Using Filters Through the API

### Dictionary Filters (Simple Approach)

For basic filtering, send a JSON object with key-value pairs. All conditions are combined with AND logic:

<CodeGroup>

```python Python Client
import requests
import json

# Simple dict filter
filter_dict = {"docs": "agno", "status": "published"}

# Serialize to JSON
filter_json = json.dumps(filter_dict)

# Send request
response = requests.post(
    "http://localhost:7777/agents/agno-knowledge-agent/runs",
    data={
        "message": "What are agno's key features?",
        "stream": "false",
        "knowledge_filters": filter_json,
    }
)

result = response.json()
```

```bash cURL
curl -X 'POST' \
  'http://localhost:7777/agents/agno-knowledge-agent/runs' \
  -H 'accept: application/json' \
  -H 'Content-Type: multipart/form-data' \
  -F 'message=What are agno'\''s key features?' \
  -F 'stream=false' \
  -F 'session_id=' \
  -F 'user_id=' \
  -F 'knowledge_filters={"docs": "agno"}'
```

</CodeGroup>

**More Dict Filter Examples:**

```python
# Filter by single field
{"category": "technology"}

# Filter by multiple fields (AND logic)
{"category": "technology", "status": "published", "year": 2024}

# Filter with different data types
{"active": True, "priority": 1, "department": "engineering"}
```

### Filter Expressions (Advanced Approach)

For complex filtering with logical operators and comparisons:

<CodeGroup>

```python Python Client
import requests
import json
from agno.filters import EQ

# Create filter expression
filter_expr = EQ("category", "technology")

# Serialize to JSON
filter_json = json.dumps(filter_expr.to_dict())

# Send request
response = requests.post(
    "http://localhost:7777/agents/my-agent/runs",
    data={
        "message": "What are the latest tech articles?",
        "stream": "false",
        "knowledge_filters": filter_json,
    }
)

result = response.json()
```

```bash cURL
curl -X 'POST' \
  'http://localhost:7777/agents/my-agent/runs' \
  -H 'Content-Type: multipart/form-data' \
  -F 'message=What are the latest tech articles?' \
  -F 'stream=false' \
  -F 'knowledge_filters={"op": "EQ", "key": "category", "value": "technology"}'
```

</CodeGroup>

### Multiple Filter Expressions

Send multiple filter expressions as a JSON array:

<CodeGroup>

```python Python Client
from agno.filters import EQ, GT

# Create multiple filters
filters = [
    EQ("status", "published"),
    GT("date", "2024-01-01")
]

# Serialize list to JSON
filters_json = json.dumps([f.to_dict() for f in filters])

response = requests.post(
    "http://localhost:7777/agents/my-agent/runs",
    data={
        "message": "Show recent published articles",
        "stream": "false",
        "knowledge_filters": filters_json,
    }
)
```

```bash cURL
curl -X 'POST' \
  'http://localhost:7777/agents/my-agent/runs' \
  -H 'Content-Type: multipart/form-data' \
  -F 'message=Show recent published articles' \
  -F 'stream=false' \
  -F 'knowledge_filters=[{"op": "EQ", "key": "status", "value": "published"}, {"op": "GT", "key": "date", "value": "2024-01-01"}]'
```

</CodeGroup>

## Filter Examples by Complexity

### Dict vs Filter Expression Comparison

Here's when to use each approach for common filtering scenarios:

| Scenario | Dict Filter ✅ | FilterExpr ⚠️ | Winner |
|----------|---------------|---------------|---------|
| Single field match | `{"status": "active"}` | `EQ("status", "active")` | **Dict** - Simpler |
| Multiple AND conditions | `{"status": "active", "year": 2024}` | `AND(EQ("status", "active"), EQ("year", 2024))` | **Dict** - More concise |
| OR conditions | Not possible | `OR(EQ("priority", "high"), EQ("urgent", True))` | **Filter Expression** - Only option |
| Range queries | Not possible | `AND(GT("price", 10), LT("price", 100))` | **Filter Expression** - Only option |
| Exclusions (NOT) | Not possible | `NOT(EQ("status", "archived"))` | **Filter Expression** - Only option |
| Complex nested logic | Not possible | `OR(AND(...), NOT(...))` | **Filter Expression** - Only option |

**Real-World Examples:**

<CodeGroup>

```json Dict: Simple AND
{
  "category": "technology",
  "status": "published",
  "year": 2024
}
```

```json Filter Expression: With OR/NOT
{
  "op": "AND",
  "conditions": [
    {"op": "EQ", "key": "status", "value": "published"},
    {
      "op": "OR",
      "conditions": [
        {"op": "EQ", "key": "priority", "value": "high"},
        {"op": "GT", "key": "views", "value": 1000}
      ]
    },
    {
      "op": "NOT",
      "condition": {"op": "EQ", "key": "status", "value": "archived"}
    }
  ]
}
```

</CodeGroup>

### Basic Filter Expression Operators

When you need more than simple AND logic, use filter expression operators:

```python
# Equality filter
EQ("status", "active")
# JSON: {"op": "EQ", "key": "status", "value": "active"}

# IN filter (multiple values)
IN("region", ["US", "EU", "APAC"])
# JSON: {"op": "IN", "key": "region", "values": ["US", "EU", "APAC"]}

# Greater than
GT("score", 80)
# JSON: {"op": "GT", "key": "score", "value": 80}

# Less than
LT("age", 65)
# JSON: {"op": "LT", "key": "age", "value": 65}
```

### Intermediate Filtering

Combine conditions with logical operators:

```python
# AND: All conditions must be true
AND(EQ("status", "published"), GT("views", 1000))

# JSON:
{
  "op": "AND",
  "conditions": [
    {"op": "EQ", "key": "status", "value": "published"},
    {"op": "GT", "key": "views", "value": 1000}
  ]
}

# OR: At least one condition must be true
OR(EQ("priority", "high"), EQ("urgent", True))

# JSON:
{
  "op": "OR",
  "conditions": [
    {"op": "EQ", "key": "priority", "value": "high"},
    {"op": "EQ", "key": "urgent", "value": true}
  ]
}

# NOT: Exclude matching documents
NOT(EQ("status", "archived"))

# JSON:
{
  "op": "NOT",
  "condition": {"op": "EQ", "key": "status", "value": "archived"}
}
```

### Advanced Filtering

Complex nested logic with multiple operators:

```python
# Complex nested conditions
OR(
    AND(EQ("type", "article"), GT("word_count", 500)),
    AND(EQ("type", "tutorial"), NOT(EQ("difficulty", "beginner")))
)

# JSON (formatted for readability):
{
  "op": "OR",
  "conditions": [
    {
      "op": "AND",
      "conditions": [
        {"op": "EQ", "key": "type", "value": "article"},
        {"op": "GT", "key": "word_count", "value": 500}
      ]
    },
    {
      "op": "AND",
      "conditions": [
        {"op": "EQ", "key": "type", "value": "tutorial"},
        {
          "op": "NOT",
          "condition": {"op": "EQ", "key": "difficulty", "value": "beginner"}
        }
      ]
    }
  ]
}
```

**Common Advanced Patterns:**

```python
# Range query: 10.0 < price < 100.0
AND(GT("price", 10.0), LT("price", 100.0))

# Multiple exclusions
NOT(IN("status", ["draft", "deleted", "archived"]))

# Complex access control
OR(
    EQ("visibility", "public"),
    AND(EQ("owner", user_id), NOT(EQ("status", "deleted")))
)
```

## How Server-Side Processing Works

The Agno API automatically handles filter expression deserialization:

<Steps>
  <Step title="Client Serialization">
    Filter expression objects are converted to dict format with `to_dict()`
  </Step>
  <Step title="JSON Transmission">
    Serialized filters are sent as JSON strings in multipart form data
  </Step>
  <Step title="API Parsing">
    Router receives and parses the JSON string back to dict
  </Step>
  <Step title="Auto-Detection">
    API detects filter expression format by checking for `"op"` key
  </Step>
  <Step title="Reconstruction">
    Filter expression objects are reconstructed from the dict structure
  </Step>
  <Step title="Agent Processing">
    Agent uses filter expression objects for knowledge base filtering
  </Step>
</Steps>

### Detection Logic

The API differentiates between filter expressions and dict filters:

```python
# Filter expression format (has "op" key)
{"op": "EQ", "key": "status", "value": "published"}
# → Deserialized to EQ("status", "published")

# Dict format (no "op" key)  
{"status": "published", "category": "tech"}
# → Kept as dict (backward compatibility)
```

## Error Handling

### Invalid Filter Structure

When filters have errors, they're gracefully ignored with warnings:

```bash
# Missing required fields
curl ... -F 'knowledge_filters={"op": "EQ", "key": "status"}'
# Result: Filter ignored, warning logged

# Unknown operator
curl ... -F 'knowledge_filters={"op": "UNKNOWN", "key": "status", "value": "x"}'
# Result: Filter ignored, warning logged

# Invalid JSON
curl ... -F 'knowledge_filters={invalid json}'
# Result: Filter ignored, warning logged
```

<Warning>
When filters fail to parse, the search proceeds **without filters** rather than throwing an error. Always verify your filter JSON is valid and check server logs if results seem unfiltered.
</Warning>

### Client-Side Validation

Add validation before sending requests:

```python
def validate_and_send_filter(filter_expr, message):
    """Validate filter before sending to API."""
    try:
        # Test serialization
        filter_dict = filter_expr.to_dict()
        filter_json = json.dumps(filter_dict)
        
        # Verify it's valid JSON
        json.loads(filter_json)
        
        # Send request
        return send_filtered_agent_request(message, filter_expr)
        
    except (AttributeError, TypeError, json.JSONDecodeError) as e:
        print(f"Filter validation failed: {e}")
        return None
```

## Choosing Between Dict and Filter Expression

Both filtering approaches work seamlessly and can be used based on your needs:

<CodeGroup>

```bash Dict Filters (Simple)
# Best for basic equality filtering
curl -X 'POST' \
  'http://localhost:7777/agents/my-agent/runs' \
  -F 'message=Query' \
  -F 'knowledge_filters={"category": "tech", "status": "published"}'
```

```bash Filter Expression (Advanced)
# Best for complex logic and comparisons
curl -X 'POST' \
  'http://localhost:7777/agents/my-agent/runs' \
  -F 'message=Query' \
  -F 'knowledge_filters={"op": "AND", "conditions": [{"op": "EQ", "key": "category", "value": "tech"}, {"op": "GT", "key": "views", "value": 1000}]}'
```

</CodeGroup>

**Decision Helper:**

```python
def create_filter(filter_type="simple"):
    """Choose filter approach based on requirements."""
    
    if filter_type == "simple":
        # Dict filters: Simple AND logic with equality
        return {"category": "tech", "status": "published"}
    
    elif filter_type == "advanced":
        # Filter expressions: Complex logic with comparisons
        return AND(
            EQ("category", "tech"),
            GT("views", 1000),
            NOT(EQ("status", "archived"))
        )
```

## Best Practices

### 1. Start Simple

Begin with basic filters and add complexity as needed:

```python
# Start here
filter = EQ("status", "published")

# Then add conditions
filter = AND(EQ("status", "published"), GT("date", "2024-01-01"))

# Finally add complex logic
filter = OR(
    AND(EQ("status", "published"), GT("date", "2024-01-01")),
    EQ("priority", "featured")
)
```

### 2. Test Locally First

Verify filter logic in Python before sending through API:

```python
from agno.filters import EQ, GT, AND

# Test serialization locally
filter_expr = AND(EQ("category", "tech"), GT("views", 100))
print(json.dumps(filter_expr.to_dict(), indent=2))

# Verify it looks correct, then use in API
```

### 3. Log Filters for Debugging

Keep track of what filters are being used:

```python
def send_with_logging(message, filters):
    """Send request with filter logging."""
    filter_json = json.dumps(filters.to_dict(), indent=2)
    print(f"Sending filter:\n{filter_json}")
    
    result = send_filtered_agent_request(message, filters)
    print(f"Got {len(result.get('documents', []))} results")
    return result
```

### 4. Handle Type Mismatches

Ensure value types match your metadata:

```python
# ✅ Correct types
EQ("status", "active")      # String
GT("count", 100)            # Integer
EQ("enabled", True)         # Boolean
GT("price", 29.99)          # Float

# ❌ Type mismatches might not match
EQ("count", "100")          # String instead of int
EQ("enabled", "true")       # String instead of bool
```

### 5. Document Your Metadata Schema

Keep track of available fields:

```python
# Document your metadata structure
METADATA_SCHEMA = {
    "status": ["draft", "published", "archived"],
    "category": ["tech", "business", "lifestyle"],
    "priority": ["low", "medium", "high", "featured"],
    "count": "integer (0-N)",
    "price": "float (USD)",
    "date": "ISO date string (YYYY-MM-DD)"
}

# Reference when building filters
def get_valid_status_filter(status):
    if status in METADATA_SCHEMA["status"]:
        return EQ("status", status)
    raise ValueError(f"Invalid status: {status}")
```

## Performance Considerations

1. **Reuse Agent Instances**: Create agents once, send multiple filtered requests
2. **Specific Filters**: Use precise filters to reduce search space
3. **Combine Conditions**: Use AND/OR instead of multiple sequential queries
4. **Index Metadata**: Ensure metadata fields are indexed in your vector database

```python
# ❌ Inefficient: Multiple sequential requests
results1 = send_request("Query", EQ("status", "published"))
results2 = send_request("Query", GT("date", "2024-01-01"))

# ✅ Efficient: Single request with combined filter
results = send_request(
    "Query", 
    AND(EQ("status", "published"), GT("date", "2024-01-01"))
)
```

## Troubleshooting

### Filter Not Working

<AccordionGroup>
  <Accordion title="Verify metadata keys exist">
    Check that the keys you're filtering on actually exist in your knowledge base:
    
    ```python
    # Add content with explicit metadata
    knowledge.add_content(
        path="doc.pdf",
        metadata={"status": "published", "category": "tech"}
    )
    
    # Now filter will work
    filter = EQ("status", "published")
    ```
  </Accordion>
  
  <Accordion title="Check filter serialization">
    Print the serialized filter to verify structure:
    
    ```python
    filter_expr = EQ("status", "published") & GT("views", 100)
    print(json.dumps(filter_expr.to_dict(), indent=2))
    ```
  </Accordion>
  
  <Accordion title="Enable debug logging">
    Check server logs for warnings about filter processing:
    
    ```bash
    # Look for filter-related warnings in Agent OS logs
    docker logs agno-agentos-1 | grep -i filter
    ```
  </Accordion>
</AccordionGroup>

### Complex Filters Failing

<AccordionGroup>
  <Accordion title="Break down into smaller filters">
    Test each condition individually:
    
    ```python
    # Test each part separately
    filter1 = EQ("status", "published")  # Test
    filter2 = GT("date", "2024-01-01")   # Test
    filter3 = IN("region", ["US", "EU"]) # Test
    
    # Then combine
    combined = AND(filter1, filter2, filter3)
    ```
  </Accordion>
  
  <Accordion title="Verify JSON validity">
    Use a JSON validator on the serialized output:
    
    ```python
    import json
    
    try:
        filter_dict = filter_expr.to_dict()
        json_str = json.dumps(filter_dict)
        json.loads(json_str)  # Verify it parses
        print("✓ Valid JSON")
    except json.JSONDecodeError as e:
        print(f"✗ Invalid JSON: {e}")
    ```
  </Accordion>
  
  <Accordion title="Check operator precedence">
    Make sure nested logic is clear and well-structured:
    
    ```python
    # Clear nested structure
    filter = OR(
        AND(EQ("a", 1), EQ("b", 2)),
        EQ("c", 3)
    )
    
    # Break down complex filters for readability
    condition1 = AND(EQ("a", 1), EQ("b", 2))
    condition2 = EQ("c", 3)
    filter = OR(condition1, condition2)
    ```
  </Accordion>
</AccordionGroup>

## Complete Examples

### Example 1: Simple Dict Filter

For straightforward filtering with AND logic:

```python
import requests
import json

# Define your agent's API endpoint
AGENT_URL = "http://localhost:7777/agents/agno-knowledge-agent/runs"

# Create simple dict filter
filter_dict = {
    "docs": "agno",
    "category": "features",
    "status": "published"
}

# Serialize filter
filter_json = json.dumps(filter_dict)

# Send request
response = requests.post(
    AGENT_URL,
    data={
        "message": "What are agno's key features?",
        "stream": "false",
        "knowledge_filters": filter_json,
        "session_id": "user-123",
        "user_id": "demo-user",
    }
)

# Process response
if response.ok:
    result = response.json()
    print(f"Agent response: {result.get('content')}")
    print(f"Documents used: {len(result.get('documents', []))}")
else:
    print(f"Error: {response.status_code} - {response.text}")
```

### Example 2: Advanced Filter Expression

For complex filtering with multiple logical operators:

```python
import requests
import json
from agno.filters import EQ, GT, AND, IN, NOT

# Define your agent's API endpoint
AGENT_URL = "http://localhost:7777/agents/tech-docs-agent/runs"

# Build a complex filter
filter_expr = AND(
    EQ("status", "published"),
    IN("category", ["tutorial", "guide"]),
    GT("word_count", 500),
    NOT(EQ("difficulty", "beginner"))
)

# Serialize filter
filter_json = json.dumps(filter_expr.to_dict())

# Send request
response = requests.post(
    AGENT_URL,
    data={
        "message": "Show me advanced tutorials on deployment",
        "stream": "false",
        "knowledge_filters": filter_json,
        "session_id": "user-123-session",
    }
)

# Process response
if response.ok:
    result = response.json()
    print(f"Agent response: {result.get('content')}")
    print(f"Documents used: {len(result.get('documents', []))}")
else:
    print(f"Error: {response.status_code} - {response.text}")
```

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Advanced Filtering Guide" 
    icon="filter"
    href="/concepts/knowledge/core-concepts/advanced-filtering"
  >
    Learn about filter expressions and metadata design in detail
  </Card>
  <Card
    title="Agent OS API"
    icon="code" 
    href="/agent-os/api"
  >
    Explore the full Agent OS API reference
  </Card>
  <Card
    title="Knowledge Bases"
    icon="database"
    href="/concepts/knowledge/core-concepts/knowledge-bases" 
  >
    Understand knowledge base architecture and setup
  </Card>
  <Card
    title="Search & Retrieval"
    icon="magnifying-glass"
    href="/concepts/knowledge/core-concepts/search-retrieval"
  >
    Optimize your search strategies
  </Card>
</CardGroup>

